#pragma kernel CSMain

// Constants
static const float PI = 3.14159265f;
static const float EPSILON = 1e-8;
static const float MAXHASH = 4294967295.0f;
// --------------------

uint seed;
uint2 pixel;
uint currSample;
uint samples;
uint maxDepth;
uint texWidth, texHeight;

// Helper functions
float Rand(){
    uint value = pixel.y * texWidth + pixel.x;
    value *= seed;
    value ^= 2747636419u;
    value *= 2654435769u;
    value ^= value >> 16;
    value *= 2654435769u;
    value ^= value >> 16;
    value *= 2654435769u;
    seed++;
    return (float)value / MAXHASH;
}

float sdot(float3 a, float3 b, float alpha = 1.0f){
    return saturate(dot(a, b) * alpha);
}

float3 RandInUnitSphere(){
    while (true){
        float x = Rand() * 2.0f - 1.0f;
        float y = Rand() * 2.0f - 1.0f;
        float z = Rand() * 2.0f - 1.0f;

        if (length(float3(x, y, z)) <= 1){
            return float3(x, y, z);
        }
    }
    return float3(0, 0, 0);
}
float3x3 GetTangentSpace(float3 normal)
{
    // Choose a helper vector for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);
    // Generate vectors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}
float3 SampleHemisphere(float3 normal)
{
    // Uniformly sample hemisphere direction
    float cosTheta = Rand();
    float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
    float phi = 2 * PI * Rand();
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}

float3 RotateFloat3(float3 v, float3 angles){
    angles *= -1;
    float sinX = sin(angles.x);
    float cosX = cos(angles.x); 

    float sinY = sin(angles.y);
    float cosY = cos(angles.y);

    float sinZ = sin(angles.z);
    float cosZ = cos(angles.z);

    float3x3 xRotator = float3x3(
        1, 0, 0,
        0, cosX, -sinX,
        0, sinX, cosX
    );
    float3x3 yRotator = float3x3(
        cosY, 0, sinY,
        0, 1, 0,
        -sinY, 0, cosY
    );
    float3x3 zRotator = float3x3(
        cosZ, -sinZ, 0,
        sinZ, cosZ, 0,
        0, 0, 1
    );
    float3x3 generalRotator = mul(mul(zRotator, xRotator), yRotator);
    return mul(v, generalRotator);
}
// ---------------
// Camera stuff
float4x4 cameraToWorld;
float4x4 cameraInverseProjection;
float3 camPos;
// ------------
// Buffers and textures
Texture2D<float4> _enviromentTex;
SamplerState sampler_enviromentTex;
float3 enviromentColor;
bool useColor;
RWStructuredBuffer<float3x3> pixels;
RWTexture2D<float4> renderTex;
RWTexture2D<float4> normalsTex;
RWTexture2D<float4> albedoTex;
StructuredBuffer<float3> verts;
StructuredBuffer<int> tris;
uint trisCount;
// ------------
class Ray{
    float3 origin, dir;

    float3 At(float t){
        return origin + t * dir;
    }

    static Ray Create(float3 origin, float3 dir){
        Ray ray;
        ray.origin = origin;
        ray.dir = dir;
        return ray;
    }
};

struct Camera{
    static Ray GetRay(float2 uv){
        // Transform the camera origin to world space
        float3 origin = mul(cameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
        
        // Invert the perspective projection of the view-space position
        float3 direction = mul(cameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
        // Transform the direction from camera to world space and normalize
        direction = mul(cameraToWorld, float4(direction, 0.0f)).xyz;
        direction = normalize(direction);

        return Ray::Create(camPos, direction);
    }
};

struct HitRecord{
    bool didHit;
    float t;
    float3 pos;
    float3 normal;
    float3 albedo;
    float specChance;
    float metalness;
    float roughness;
    float3 emission;
};

class Sphere{
    float3 center;
    float radius;
    float3 albedo;
    float specChance;
    float metalness;
    float roughness;
    float3 emission;

    HitRecord Hit(Ray ray, float tMin, float tMax){
        float3 oc = ray.origin - center;
        float a = dot(ray.dir, ray.dir);
        float half_b = dot(oc, ray.dir);
        float c = dot(oc, oc) - radius * radius;
        float discriminant = half_b * half_b - a * c;
        float root = (-half_b - sqrt(discriminant)) / a;
        HitRecord rec;
        if (discriminant < 0.0f || root < tMin || root > tMax){
            rec.didHit = false;
            return rec;
        }
        rec.didHit = true;
        rec.t = root;
        rec.pos = ray.At(rec.t);
        rec.normal = (rec.pos - center) / radius;
        rec.albedo = albedo;
        rec.specChance = specChance;
        rec.metalness = metalness;
        rec.roughness = roughness;
        rec.emission = emission;
        return rec;
    }
};
class Triangle{
    float3 vert0;
    float3 vert1;
    float3 vert2;

    HitRecord Hit(Ray ray, float tMin, float tMax){
        HitRecord rec;
        rec.didHit = false;
        // find vectors for two edges sharing vert0
        float3 edge1 = vert1 - vert0;
        float3 edge2 = vert2 - vert0;
        // begin calculating determinant - also used to calculate U parameter
        float3 pvec = cross(ray.dir, edge2);
        // if determinant is near zero, ray lies in plane of triangle
        float det = dot(edge1, pvec);
        // use backface culling
        if (det < EPSILON){
            return rec;
        }
        float inv_det = 1.0f / det;
        // calculate distance from vert0 to ray origin
        float3 tvec = ray.origin - vert0;
        // calculate U parameter and test bounds
        float u = dot(tvec, pvec) * inv_det;
        if (u < 0.0 || u > 1.0f){
            return rec;
        }
        // prepare to test V parameter
        float3 qvec = cross(tvec, edge1);
        // calculate V parameter and test bounds
        float v = dot(ray.dir, qvec) * inv_det;
        if (v < 0.0 || u + v > 1.0f){
            return rec;
        }
        float t = dot(edge2, qvec) * inv_det;

        if (t < tMin || t > tMax){
            return rec;
        }
        rec.didHit = true;
        rec.t = t;
        rec.pos = ray.At(t);
        rec.normal = normalize(cross(vert1 - vert0, vert2 - vert0));
        return rec;
    }

    static Triangle Create(float3 vert0, float3 vert1, float3 vert2){
        Triangle tri;
        tri.vert0 = vert0;
        tri.vert1 = vert1;
        tri.vert2 = vert2;
        return tri;
    }
};

class MeshObject{
    float3 pos;
    float3 scale;
    float3 rotation;

    float3 albedo;
    float specChance;
    float metalness;
    float roughness;
    float3 emission;

    int trisStart;
    int trisEnd;

    HitRecord Hit(Ray ray, float tMin, float tMax){
        HitRecord rec; 
        rec.didHit = false;
        rec.t = tMax;
        for (int i = trisStart; i <= trisEnd; i += 3){
            float3 vert0 = RotateFloat3(verts[tris[i]], rotation * PI / 180.0f) * scale + pos;
            float3 vert1 = RotateFloat3(verts[tris[i + 1]], rotation * PI / 180.0f) * scale + pos;
            float3 vert2 = RotateFloat3(verts[tris[i + 2]], rotation * PI / 180.0f) * scale + pos;

            Triangle tri = Triangle::Create(vert0, vert1, vert2);
            HitRecord tempRec = tri.Hit(ray, tMin, tMax);

            if (tempRec.didHit){
                rec = tempRec;
            }
        }

        rec.albedo = albedo;
        rec.specChance = specChance;
        rec.metalness = metalness;
        rec.roughness = roughness;
        rec.emission = emission;
        return rec;
    }
};

// Hittable Objects
RWStructuredBuffer<Sphere> spheres;
uint sphereCount;
RWStructuredBuffer<MeshObject> meshObjects;
uint meshObjectCount;
// -----------
float3 SampleEnviroment(Ray ray){
    float theta = acos(ray.dir.y) / -PI;
    float phi = atan2(ray.dir.x, -ray.dir.z) / -PI * 0.5f;
    float4 _sample = _enviromentTex.SampleLevel(sampler_enviromentTex, float2(phi, theta), 0);
    return useColor ? enviromentColor : float3(_sample.x, _sample.y, _sample.z);
}

float3x3 GetPixelColors(Ray ray, float tMin, float tMax){
    float3 color = 1.0f;
    float3 normal = 0.0f;
    float3 albedo = 0.0f;

    for (uint depth = 1; depth <= maxDepth; depth++){
        HitRecord rec;
        rec.didHit = false;
        rec.t = tMax;

        for (uint i = 0; i < sphereCount; i++){
            Sphere sphere = spheres[i];
            HitRecord tempRec = sphere.Hit(ray, tMin, rec.t);

            if (tempRec.didHit){
                rec = tempRec;
            }
        }
        for (uint j = 0; j < meshObjectCount; j++){
            MeshObject meshObject = meshObjects[j];
            HitRecord tempRec = meshObject.Hit(ray, tMin, rec.t);

            if (tempRec.didHit){
                rec = tempRec;
            }
        }
        if (!rec.didHit){
            color *= SampleEnviroment(ray);
            break;
        }

        float3 newDir;
        float3 specularDir = reflect(ray.dir, rec.normal) + rec.roughness * RandInUnitSphere();
        float3 diffuseDir = SampleHemisphere(rec.normal);

        float fresnel = 1.0f - sdot(rec.normal, specularDir);
        float specularIntensity = pow(abs((1.0f-(1.0f-rec.metalness)*cos(PI/2.0f * fresnel))/(1.0f+(1.0f-rec.metalness)*cos(PI/2.0f*fresnel))), 2.0f);

        float3 attenuation;

        if (Rand() <= rec.specChance * specularIntensity){
            newDir = specularDir;
            attenuation = lerp(1, rec.albedo, rec.metalness);
        }
        else{
            newDir = diffuseDir;
            attenuation = rec.albedo;
        }

        color *= rec.emission + attenuation;
        if (depth == 1){
            normal = rec.normal;
            albedo = rec.albedo;
        }
        
        if (length(rec.emission) != 0.0f) break;
        ray = Ray::Create(rec.pos + rec.normal * 0.0001f, newDir);
    }
    return float3x3(color, normal, albedo);
}

[numthreads(30,30,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    pixel = id.xy;
    uint i = id.y * texWidth + id.x;
    if (currSample == 1){
        pixels[i] = 0.0f;
        normalsTex[id.xy] = 0.0f;
        albedoTex[id.xy] = 0.0f;
    }
    float2 uv = float2(((float)id.x + Rand()) / (texWidth), ((float)id.y + Rand()) / (texHeight)) * 2.0f - 1.0f;
    Ray ray = Camera::GetRay(uv);
    float3x3 colors = GetPixelColors(ray, 0, 1.#INF);

    pixels[i][0] += colors[0];
    pixels[i][1] += colors[1];
    pixels[i][2] += colors[2];
    renderTex[id.xy] = float4(pixels[i][0] / (float)currSample, 1);
    normalsTex[id.xy] = float4(pixels[i][1] / (float)currSample, 1);
    albedoTex[id.xy] = float4(pixels[i][2] / (float)currSample, 1);
}
